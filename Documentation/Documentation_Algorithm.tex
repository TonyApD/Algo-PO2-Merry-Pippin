\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand{\bigO}[1]{\mathcal{O}(#1)}
\newcommand{\textHighlight}[1]{\textcolor{red}{#1}}

\begin{document}

\title{Practical assignment 2 \\ Algorithms \& Datastructures}
\author{Carlo Jessurun s1013793 \\ Tony Lopar s1013792}
\date{\parbox{\linewidth}{\centering%
  Nijmegen, \today\endgraf\bigskip
  Frits Vaandrager\endgraf\medskip
  Joshua Moerman\endgraf\medskip
  2017-2018 \endgraf
  Radboud University Nijmegen}}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Explanation}
In this chapter we will explain how our algorithm works. The explentation is split into three parts.

\subsection{Reading the input}
For the reading of the input we made a custom reader which replaces the scanner in Java. The custom reader works faster than the standard scanner in Java. \newline
At first we reused our last implementation of the scanner class we did in the first assignment. In this instance however, we found it to perform quite slowly and it was definitely holding the speed back a lot. So after researching replacements for the scanner class we found that the BufferedReader was a way faster class to use. To give a short summary of our research we found the following information about both the Scanner and the BufferedReader:
\newline
\newline
\textbf{The java.util.Scanner} class is a simple text scanner which can parse primitive types and strings. It internally uses regular expressions to read different types.
\newline
\newline
\textbf{Java.io.BufferedReader} class reads text from a character-input stream, buffering characters so as to provide for the efficient reading of sequence of characters.
\begin{itemize}
\item BufferedReader is synchronous while Scanner is not. BufferedReader should be used if we are working with multiple threads.
\item BufferedReader has significantly larger buffer memory than Scanner.
\item The Scanner has a little buffer (1KB char buffer) as opposed to the BufferedReader (8KB byte buffer), but itâ€™s more than enough.
\item BufferedReader is a bit faster as compared to scanner because scanner does parsing of input data and BufferedReader simply reads sequence of characters.
\end{itemize}
Since we found that is fast, it's still not recommended as it requires lot of typing. The BufferedReader class reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines. With this method we will have to parse the value every time for desired type.
\newline
\newline
At this point we decided to use our own implementation of a Reader class with the use of DataInputStream. This provided us with a really fast way to read the input given by this assignment. We found it to be the fastest of all our tested reader implementations but it does require very cumbersome methods in its implementation. It uses DataInputStream to read through the stream of data and uses read() method and nextInt() methods for taking inputs. This is by far the fastest ways of taking input but is difficult to remember and is cumbersome in its approach. Our implementation can be found in the ``Reader.java'' class. We used the test data we got from the algorithms website but also tested our other scanners against the website ``http://www.spoj.com/problems/INTEST''\footnote{\label{note1}http://www.spoj.com/problems/INTEST/} which is basically a huge place to test how fast you can read data. The ``Reader.java'' class also performed really fast on this testing framework.
\newline
\newline
Since we did not want to constantly depend on testing with the ads.cs.ru.nl framework we copied the tests to a local machine. We've used JUnit\footnote{\label{note1}http://junit.org/junit4/} to make unittests and used those to test, debug and validate our code. The implementation (not necessary) can be seen in ``ExampleCases.java''. Those 45 testcases include those of the testframework in ads.cs.ru.nl and we saw a very significant improvement on the runtime after implementing the new Reader class. In the end, comparing with the default scanner implementation we saved a lot of time and made reading input literally ten times faster over the entire testset.
\begin{itemize}
\item \textbf{Scanner implementation:} 400ms
\item \textbf{DataInputStream implementation:} 38ms
\end{itemize}

\subsection{Algorithm}
The algorithm first tries to make profitable groups of the input. Products are added to the previous group when after addition the group still gives profit.

After this the algorithm optimizes the list with profits by putting groups with a higher profit in front of the list.

Finally the first D profits are substracted from the total sum of products where D is the number of dividers.

\subsection{Computing output}

\newpage
\section{Analysis}

\subsection{Correctness}
In this section we will discuss the Correctness of the processes.

\subsubsection{Reading the input}

\subsubsection{Algorithm}

\subsubsection{Computing output}

\subsection{Complexity}
In this chapter we will describe the complexity of our algorithm. We will first describe the complexity in detail for the smaller parts and after this compute the complexity for the whole algorithm. The parts which depend on the number of dividers are indicated by $|D|$.

\begin{itemize}
  \item Reading the input: $\bigO{n}$
  \item Algorithm: $\bigO{n}$
  \item Writing output: $\bigO{1}$
  \item \textbf{Total algorithm:} $\bigO{n}$
\end{itemize}

\subsubsection{Reading the input}
The reading of the input has to process all items in the input for the algorithm. Before we read the prices of the products, we have to read the number of products and the number of dividers. This means that in total $n + 2$ items should be read from the input. The complexity of this reading is $\bigO{n}$.

The algorithm starts with reading the input. This is done in a loop which reads all the values from the input. The input starts with the number of products and dividers followed by the prizes of all products. This gives a complexity of $\bigO{n}$. The custom reader only opens and closes a connection which has a complexity of $\bigO{n}$, so the total complexity of reading the input is $\bigO{n}$.

\subsubsection{Algorithm}
The algorithm itself has 3 steps in total. The first step is to find groups with potential profit. Therefore, there is looped once over all items of the input. In the loop there is an if else which adds a group to the potentialProfitList or not. Whether we add a product to the list is done based on whether a given product itself is profitable or not. We calculate this by taking the mod 10 of a product's price and look if it is 4. If a combination of two, tree or four products together make 4 ([1,1,1,1]) we add those to the list as 4 as well. If we otherwise for example find a group of 3 after which the next value is 2, we then add the 3 and start with 2 as our new value to see if we can make a higher potential profit. The complexity of this whole process depends on the number of executions in the loop. This gives a complexity of $\bigO{n}$.

The second part of the algorithm is to optimize the list of profitable groups. In this process a loop is executed which iterates over all groups found in the previous step. In the worst case the previous step only created groups with one product. This means that this process has a complexity of $\bigO{n}$.

The last step of the algorithm is substracting the first $|D|$ elements from the optimized list with profits. This process has a loop which iterates through all items of the optimizedProfitList. However, this loop is terminated when there are no dividers anymore. This means that the number of times the loop is executed is $|D|$ when $|D| \leq n$. So, the worst case is when there are more dividers than products. This results in a complexity of $\bigO{n}$ for this process.

The algorithm has three processes which are performed after each other. All of these processes have a complexity of $\bigO{n}$ which give a total complexity of $\bigO{3n}$. Since this complexity depends on n we may write it as $\bigO{n}$.

\subsubsection{Writing output}
The result of the the last process of the algorithm is given to the output. Before writing the output, this result is rounded up or down depending on the last digit. If the last digit is 0 until 4, the total is round down. Otherwise the total is rounded up. After this the rounded result is printed to the system. Both operations are performed in constant time which results in a complexity of $\bigO{1}$.

\newpage
\section{Reference}

\end{document}
