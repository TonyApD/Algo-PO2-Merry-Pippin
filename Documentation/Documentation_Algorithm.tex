\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand{\bigO}[1]{\mathcal{O}(#1)}
\newcommand{\textHighlight}[1]{\textcolor{red}{#1}}

\begin{document}

\title{Practical assignment 2 \\ Algorithms \& Datastructures}
\author{Carlo Jessurun s1013793 \\ Tony Lopar s1013792}
\date{\parbox{\linewidth}{\centering%
  Nijmegen, \today\endgraf\bigskip
  Frits Vaandrager\endgraf\medskip
  Joshua Moerman\endgraf\medskip
  2017-2018 \endgraf
  Radboud University Nijmegen}}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Explanation}
In this chapter we will explain how our algorithm works. The explentation is split into three parts.

\subsection{Reading the input}
For the reading of the input we made a custom reader which replaces the scanner in Java. The custom reader works faster than the standard scanner in Java. \textbf{Uitleg waarom sneller?}

\subsection{Algorithm}
The algorithm first tries to make profitable groups of the input. Products are added to the previous group when after addition the group still gives profit.

After this the algorithm optimizes the list with profits by putting groups with a higher profit in front of the list.

Finally the first D profits are substracted from the total sum of products where D is the number of dividers.

\subsection{Computing output}

\newpage
\section{Analysis}

\subsection{Correctness}
In this section we will discuss the Correctness of the processes.

\subsubsection{Reading the input}

\subsubsection{Algorithm}

\subsubsection{Computing output}

\subsection{Complexity}
In this chapter we will describe the complexity of our algorithm. We will first describe the complexity in detail for the smaller parts and after this compute the complexity for the whole algorithm. The parts which depend on the number of dividers are indicated by $|D|$.

\begin{itemize}
  \item Reading the input: $\bigO{n}$
  \item Algorithm: $\bigO{n}$
  \item Writing output: $\bigO{1}$
  \item \textbf{Total algorithm:} $\bigO{n}$
\end{itemize}

\subsubsection{Reading the input}
The reading of the output has to process all items in the output for the algorithm. Before we read the prices of the products, we have to read the number of products and the number of dividers. This means that in total $n + 2$ items should be read from the input. The complexity of this reading is $\bigO{n}$.

The algorithm starts with reading the input. This is done in a loop which reads all the values from the input. The input starts with the number of products and dividers followed by the prizes of all products. This gives a complexity of $\bigO{n}$. The custom reader only opens and closes a connection which has a complexity of $\bigO{n}$, so the total complexity of reading the input is $\bigO{n}$.

\subsubsection{Algorithm}
The algorithm itself has 3 steps in total. The first step is to find groups with potential profit. Therefore, there is looped once over all items of the input. In the loop there is an if else which adds a group to the potentialProfitList or not. The complexity of this whole process depends on the number of executions in the loop. This gives a complexity of $\bigO{n}$.

The second part of the algorithm is to optimize the list of profitable groups. In this process a loop is executed which iterates over all groups found in the previous step. In the worst case the previous step only created groups with one product. This means that this process has a complexity of $\bigO{n}$.

The last step of the algorithm is substracting the first $|D|$ elements from the optimized list with profits. This process has an loop which iterates through all items of the optimizedProfitList. However, this loop is terminated when there are no dividers anymore. This means that the number of times the loop is executed is $|D|$ when $|D| \leq n$. So, the worst case is when there are more dividers than products. This results in a complexity of $\bigO{n}$ for this process.

The algorithm has three processes which are performed after each other. All of these processes have a complexity of $\bigO{n}$ which give a total complexity of $\bigO{3n}$. Since this complexity depends on n we may write it as $\bigO{n}$.

\subsubsection{Writing output}
The result of the the last process of the algorithm is given to the output. Before writing the output, this result is rounded up or down depending on the last digit. If the last digit is 0 until 4, the total is round down. Otherwise the total is rounded up. After this the rounded result is printed to the system. Both operations are performed in constant time which results in a complexity of $\bigO{1}$.

\newpage
\section{Reference}

\end{document}
